---
title: Optimizing Ruby Code in C
layout: slideshow
location_and_date: NYC.rb, 13 April 2010
---

<ul id="slideShow">
	<li class="title">
	<h1>{{ page.title }}</h1>
	<h3>It's not as scary as you think.</h3>
	<h3>Mat Brown</h3>
	<h3>Patch Media</h3>
</li>
<li>
	<h1>The Goal</h1>
	<p class="definition">
		Optimize ActiveSupport's string interpolation methods in native code for better performance.
	</p>
	<p class="definition">(C is very good at processing strings)</p>
</li>
<li>
	<h1>Some Globals</h1>
	<pre><code>VALUE NativeSupport;
VALUE NativeSupport__Inflector;</code></pre>
	<p>
		These variables will hold references to the classes we define. We could also
		define them in Ruby.
	</p>
</li>
<li>
	<h1>Method Headers</h1>
	<pre><code>void Init_native_support();

VALUE method_dasherize(VALUE self, VALUE str);</code></pre>
	<p>
		The <code>Init_native_support</code> method is called by the Ruby interpreter
		when the native extension is loaded. We'll use that to set up our Ruby
		modules and methods.
	</p>
	<p>
		The <code>method_dasherize</code> method will be the actual C implementation
		of our Ruby method.
	</p>
</li>
<li>
	<h1>Initialize the extension</h1>
	<pre><code>void Init_native_support() {
    NativeSupport = rb_define_module("NativeSupport");
    NativeSupport__Inflector = rb_define_module_under(NativeSupport, "Inflector");
  
    rb_define_singleton_method(NativeSupport__Inflector, "dasherize", method_dasherize, 1);
}</code></pre>
	<p>
		First, create the <code>NativeSupport</code> and
		<code>NativeSupport::Inflector</code> modules. Then add the
		<code>dasherize</code> as a class method of
		<code>NativeSupport::Inflector</code>, which is implemented by the C method
		<code>method_dasherize</code> and takes one argument.
	</p>
</li>
<li>
	<h1>Implement the method</h1>
    <pre><code>VALUE method_dasherize(VALUE self, VALUE str) {
    char * orig_str = RSTRING_PTR(str);
    int orig_str_len = RSTRING_LEN(str);
    VALUE dasherized_ruby_str = rb_str_dup(str);
    rb_str_modify(dasherized_ruby_str);
    char * dasherized_str = RSTRING_PTR(dasherized_ruby_str);
    int i;
    
    for (i = 0; i &lt; orig_str_len; i++) {
        if (orig_str[i] == '_') {
            dasherized_str[i] = '-';
        }
    }
    
    return dasherized_ruby_str;
}</code></pre>
	<p>Whoa: let's break it down.</p>
</li>
<li>
	<h1>Break it down</h1>
	<pre><code>char * orig_str = RSTRING_PTR(str);
int orig_str_len = RSTRING_LEN(str);</code></pre>
	<p>
		Using Ruby C macros, get access to a pointer containing the C character array
		encapsulated by the Ruby String object, and an integer containing the length
		of the string.
	</p>
</li>
<li>
	<h1>Break it down</h1>
	<pre><code>VALUE dasherized_ruby_str = rb_str_dup(str);
rb_str_modify(dasherized_ruby_str);
char * dasherized_str = RSTRING_PTR(dasherized_ruby_str);</code></pre>
	<p>
		Duplicate the input String. This creates a new Ruby object, but
		<strong>it encapsulates the same underlying C string</strong>. So, call
		<code>rb_str_modify</code> to tell the Ruby interpreter that we're going
		to be making changes to the underlying C string, and it should copy the
		contents of the string into a new C array. Then get a reference to the new
		underlying C array.
	</p>
</li>
<li>
	<h1>Break it down</h1>
	<pre><code>int i;
for (i = 0; i &lt; orig_str_len; i++) {
    if (orig_str[i] == '_') {
        dasherized_str[i] = '-';
    }
}</code></pre>
	<p>
		Iterate over each character in the string, changing it to a dash if the
		original is an underscore.
	</p>
</li>
<li>
	<h1>That's all there is to it!</h1>
	<p>
		That was a pretty trivial example, but other methods have more interesting
		implementations &mdash; and some impressive-looking speedups.
	</p>
	<p>
		However, it doesn't seem to have much effect on the overall performance
		of a Rails application.
	</p>
</li>
</ul>

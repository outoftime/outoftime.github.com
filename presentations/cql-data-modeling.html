<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Big data modeling with Cassandra</title>

		<meta name="description" content="How to use CQL3 to construct robust,
        highly scalable data models">
		<meta name="author" content="Mat Brown">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">
		<link rel="stylesheet" href="css/custom.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
                <h1>Big data modeling with Cassandra</h1>
				</section>

                <section data-background="images/mat.jpg">
                <h1>Mat Brown</h1>
                <h3>@0utoftime</h3>
                <h3>github.com/outoftime</h3>
                <h3>Rap Genius</h3>
                <aside class="notes">
                <ul>
                <li>used Cassandra/CQL2 at Brewster</li>
                <li>maintain Cequel ORM</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>Why Cassandra?</h1>
                </section>

                <section>
                <section>
                <h1>Scalability</h1>
                <img src="images/nettop.jpg">

                <aside class="notes">
                <ul>
                <li>in a relational database, all your data lives on one
                machine</li>
                <li>in the early stages, any hardware will do</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>Scalability</h1>
                <img src="images/server.jpg">
                <aside class="notes">
                <ul>
                <li>as your data set grows and access volume increases, better
                hardware needed</li>
                </aside>
                </section>

                <section>
                <h1>Scalability</h1>
                <img src="images/supercomputer.jpg">
                <aside class="notes">
                <ul>
                <li>you can scale vertically for a while</li>
                <li>but eventually your requirements get out of hand</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>Failure Tolerance</h1>
                <img src="images/tiefighter.jpg">
                <aside class="notes">
                <ul>
                <li>you never know when a server is going to go down</li>
                <li>in a single-master data store, losing your master =
                downtime</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>Distributed Databases</h1>
                <img src="images/server-ring.jpg">

                <aside class="notes">
                <ul>
                <li>distributed store solves both problems</li>
                <li>multiple copies replicated across nodes</li>
                <li>scale out by adding machines</li>
                <li>masterless = node failures are transparent to the
                client</li>
                </ul>
                </aside>

                <aside class="explanation">
                A distributed data store can solve both of these problems. You
                can scale out horizontally, simply by adding more machines to
                the ring. And in a masterless data store, a node going down is
                typically transparent to clients.
                </aside>
                </section>

                <section>
                <h1>Write Optimization</h1>
                <img src="images/firehose.jpg">

                <aside class="notes">
                <ul>
                <li>optimized for large write volumes</li>
                <li>files never modified on disk, only appending or new ones created</li>
                </ul>
                </aside>

                <aside class="explanation">
                Cassandra is optimized for large write volumes. Its
                log-structured storage never updates existing files on disk; it
                only creates new files.
                </side>
                </section>
                </section>

                <section>
                <section>
                <h1>OK, but why Cassandra?</h1>
                <img src="images/fault-tolerance.png">

                <aside class="notes">
                <ul>
                <li>lots of distributed data stores available
                <ul><li>Riak</li><li>HBase</li><li>Voldemort</li></ul>
                </li>
                <li>often difficult and unfamiliar to work with</li>
                </ul>
                </section>

                <section>
                <h1>Tables, Rows, and Columns</h1>
                <table>
                    <tr>
                        <th>id</th>
                        <th>title</th>
                        <th>body</th>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>Big Data Modeling with Cassandra</td>
                        <td>In a traditional relational database, all your data...</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Ulysses</td>
                        <td>Stately, plump Buck Mulligan came from the stairhead...</td>
                    </tr>
                </table>

                <aside class="notes">
                <ul>
                <li>data structured in tables, rows, and columns</li>
                <li>looks like a relational database</li>
                </ul>
                </aside>

                <aside class="explanation">
                Cassandra structures data in tables, rows, and columns, just
                like an SQL database.
                </aside>
                </section>

                <section>
                <h1>CQL</h1>
                <pre><code data-trim class="language-sql">
SELECT title, body
FROM documents
WHERE id = 1
                </code></pre>

                <aside class="notes">
                <ul>
                <li>CQL is an SQL-like language, very similar grammar and
                semantics</li>
                <li>CQL3 is the most SQL-like</li>
                </ul>
                </aside>

                <aside class="explanation">
                Even better, data is accessed and manipulated using CQL, a query
                language inspired by SQL. So you can get all the benefits of a
                write-optimized distributed database while still modeling and
                interacting with your data in a familiar way.
                </aside>
                </section>
                </section>

                <section>
                <section>
                <h1>Why not Cassandra?</h1>
                </section>
                <section>
                <h1>A<span class="fragment">C</span><span class="fragment">I</span><span class="fragment">D</span></h1>
                <p>Atomic</p>
                <p class="fragment" data-fragment-index="0">Consistent</p>
                <p class="fragment" data-fragment-index="1">Isolated</p>
                <p class="fragment" data-fragment-index="2">Durable</p>

                <aside class="notes">
                <ul>
                <li>Atomic
                    <ul>
                    <li>Batch statements applied atomically</li>
                    <li>But no concept of a transaction spanning multiple queries</li>
                    </ul>
                </li>
                <li>Consistent: No data integrity constraints
                    <ul>
                    <li>non-NULL columns</li>
                    <li>unique indexes</li>
                    <li>foreign keys</li>
                    </ul>
                    <ul>
                    <li>INSERT at an existing primary key will just overwrite</li>
                    <li>Cassandra 2.0 does have conditional inserts</li>
                    </ul>
                </li>
                <li>Isolated: writes are isolated at the "Wide Row" level</li>
                <li>Durable: Write is only successful once durably written</li>
                </aside>


                <aside class="explanation">
                <p>A series of statements sent as a batch will be applied
                atomically, but there is no concept of multi-statement
                transactions, ROLLBACK, etc.</p>
                <p>Cassandra does not support data integrity constraints such as
                NOT NULL columns, unique indices, foreign keys, etc. Even
                primary keys uniqueness is enforced by simply overwriting data
                at an already existing key. So, there is no concept of
                consistency from the standpoint of ACID.</p>
                <p>Writes in the context of a "transaction" are isolated at the
                row level. We'll get a better sense of what the "row level"
                means later in the presentation.</p>
                <p>Data written to Cassandra is highly durable; write operations
                will not report success until data is persisted durably to disk,
                possibly with multiple copies.</p>
                </aside>
                </section>
                </section>

                <section>
                <section>
                <h1>Data Modeling</h1>
                <p>Let's make a blog!</p>
                </section>

                <section>
                <h1>Blog Table</h1>
                <pre><code data-trim class="language-sql">
CREATE TABLE blogs (
    subdomain varchar PRIMARY KEY,
    name varchar,
    description varchar
)
                </code></pre>

                <aside class="notes">
                Looks just like a relational database table
                </aside>

                <aside class="explanation">
                Pretty simple – looks exactly like an SQL table. Note that
                the primary key is text: Cassandra doesn't have
                auto-incrementing primary keys, so you will either want to use a
                natural key or a UUID.
                </aside>
                </section>

                <section>
                <h1>Posts Table</h1>
                <pre><code data-trim class="language-sql">
CREATE TABLE posts (
    blog_subdomain varchar,
    id timeuuid,
    title text,
    author_id uuid,
    PRIMARY KEY (blog_subdomain, id)
) 
                </code></pre>
                <pre class="fragment"><code data-trim class="language-sql">
CREATE INDEX ON posts (author_id)
                </code></pre>
                <pre class="fragment"><code data-trim class="language-sql">
ALTER TABLE posts ADD categories set&lt;text&gt;
                </code></pre>


                <aside class="notes">
                <ul>
                <li>compound primary key</li>
                <li>blog_subdomain is "partition key"; groups related rows.</li>
                <li>parent-child relationship.</li>
                <li>id is a "clustering column"; rows are stored sorted by this</li>
                <li>No auto-incrementing primary keys; use UUIDs or natural keys</li>
                </ul>

                <ul>
                <li>Secondary indices: don't rely too heavily, best when each
                value has lots of rows</li>
                </ul>

                <ul>
                <li>Collection columns: list, set, map</li>
                <li>Can be updated atomically, but are always read in full.</li>
                </ul>
                </aside>

                <aside class="explanation">
                <p>Here we have a more interesting example: a compound primary key.
                The primary key is comprised of two columns, which play
                different roles. The first column of the key is called the
                "partition key"; it identifies a collection of related rows, in
                this case the posts in a particular blog. The second column of
                the key is called the "clustering column"; this works much like
                an indexed column in a relational database, allowing you to
                efficiently order by this column and select ranges from it.</p>

                <p>Cassandra supports secondary indexes on non-key columns. It's
                usually recommended that you index columns that have many rows
                per unique value of the column.</p>

                <p>Cassandra also supports collection columns: lists, sets, and
                maps. Using CQL, you can perform atomic mutation operations on
                collection columns.</p>
                </section>
                </section>

                <section>
                <section>
                <h1>Under the hood</h1>

                <aside class="notes">
                <ul>
                <li>CQL is an abstraction</li>
                <li>interface to the underlying representation via Thrift</li>
                <li>no need to use it, but important to understand</li>
                </ul>
                </aside>

                </section>
                <section>
                <h1>Column families</h1>
                <pre><code class="ruby">
{
  "big-data" =&gt; {1 =&gt; 'Cassandra', 2 =&gt; 'Riak', 4 =&gt; 'HBase'},
  "relational" =&gt; {2 =&gt; 'SQLite', 7 =&gt; 'MySQL'}
}
                </code></pre>

                <aside class="notes">
                <ul>
                <li>like a hash whose values are nested hashes</li>
                <li>inner hashes maintain keys in sorted order</li>
                </ul>
                </aside>

                <aside class="explanation">
                Under the hood, Cassandra stores data in simple structures
                called column families. You can think of a column family as a
                hash, where each value is a nested hash whose keys are kept
                in sorted order.
                </aside>
                </section>

                <section>
                <h1>Column Families</h1>
                <table>
                    <tr>
                        <th rowspan="2" style="background-color: dimgray"><code>big-data</code></th>
                        <th style="background-color: darkslategray">1</td>
                        <th style="background-color: darkslategray">2</td>
                        <th style="background-color: darkslategray">4</td>
                    </tr>
                    <tr>
                        <td>Cassandra</td>
                        <td>Riak</td>
                        <td style="border-bottom: 10px solid gray">HBase</td>
                    </tr>
                    <tr style="border-top: 10px solid gray">
                        <th rowspan="2" style="background-color: dimgray"><code>relational</th>
                        <th style="background-color: darkslategray">2</td>
                        <th style="background-color: darkslategray">7</td>
                    </tr>
                    <tr>
                        <td>SQLite</td>
                        <td>MySQL</td>
                    </tr>
                </table>

                <aside class="notes">
                <ul>
                <li>underlying representation
                <li>called a "column family"</li>
                <li>"column" idea misleading here; each row can have different
                column "names"</li>
                <li>column names can be of any type; here they are integers</li>
                <li>a row can hold about 2 billion columns</li>
                <li>called a "wide row"</li>
                </ul>
                </aside>

                <aside class="explanation">
                Another way of looking at the same data. Note that the column
                headers don't have to be consistent between rows. Each row of a
                column family can get up to about 2 billion entries without much
                trouble. We call these "wide rows".
                </aside>
                </section>
                <section>
                <h1>Wide rows stick together</h1>
                <table style="position: relative; top: 1em; left: -10em">
                    <tr>
                        <th rowspan="2" style="background-color: dimgray"><code>big-data</code></th>
                        <th style="background-color: darkslategray">1</td>
                        <th style="background-color: darkslategray">2</td>
                        <th style="background-color: darkslategray">4</td>
                    </tr>
                    <tr>
                        <td>Cassandra</td>
                        <td>Riak</td>
                        <td>HBase</td>
                    </tr>
                </table>
                <table style="position: relative; top: 5em; left: 5em">
                    <tr>
                        <th rowspan="2" style="background-color: dimgray"><code>relational</th>
                        <th style="background-color: darkslategray">2</td>
                        <th style="background-color: darkslategray">7</td>
                    </tr>
                    <tr>
                        <td>SQLite</td>
                        <td>MySQL</td>
                    </tr>
                </table>

                <aside class="notes">
                <ul>
                <li>each wide row lives in a contiguous space on disk</li>
                <li>data on disk is in sorted order</li>
                <li>querying for a range of columns requires one sequential scan
                of the disk; very efficient</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>Compound Types</h1>
                <pre><code>
(2013-05-03, "bikini whale")
(2013-05-03, "manta ray")
(2013-07-08, "catfish")
(2013-07-08, "narwhal")
(2013-09-13, "giant clam")
                </code></pre>

                <aside class="notes">
                <ul>
                <li>support for compound types</li>
                <li>sorted lexically, much like an array</li>
                <li>we'll see compound types used for wide row column
                headers</li>
                </ul>
                </section>

                <section>
                <h1>Back to the blog</h1>
                <table>
                    <tr>
                        <th>blog_subdomain</th>
                        <th>id</th>
                        <th>title</th>
                        <th>body</th>
                    </tr>
                    <tr>
                        <td>mycat</td>
                        <td>2013-05-08</td>
                        <td>Jumping in a box</td>
                        <td>Taco loves jumping in boxes.</td>
                    </tr>
                    <tr>
                        <td>mycat</td>
                        <td>2013-08-17</td>
                        <td>Hungry Cat</td>
                        <td>Taco is always hungry when I get home from
                            work.</td>
                    </tr>
                    <tr>
                        <td>code</td>
                        <td>2013-07-08</td>
                        <td>Big Data Modeling</td>
                        <td>In a traditional relational database, all your data...</td>
                    </tr>
                </table>

                <aside class="notes">
                <ul>
                <li>here's how the blog looks logically, in the CQL
                structure</li>
                </ul>
                </aside>
                </section>

                <section data-transition="none">
                <h1>Back to the blog</h1>
                <table>
                    <tr>
                        <th>blog_subdomain</th>
                        <th>id</th>
                        <th style="color: chartreuse">title</th>
                        <th style="color: chartreuse">body</th>
                    </tr>
                    <tr>
                        <td style="color: red">mycat</td>
                        <td style="color: cyan">2013-05-08</td>
                        <td style="color: orange">Jumping in a box</td>
                        <td style="color: orange">Taco loves jumping in boxes.</td>
                    </tr>
                    <tr>
                        <td style="color: red">mycat</td>
                        <td style="color: cyan">2013-08-17</td>
                        <td style="color: orange">Hungry Cat</td>
                        <td style="color: orange">Taco is always hungry when I get home from
                            work.</td>
                    </tr>
                    <tr>
                        <td style="color: red">code</td>
                        <td style="color: cyan">2013-07-08</td>
                        <td style="color: orange">Big Data Modeling</td>
                        <td style="color: orange">In a traditional relational database, all your data...</td>
                    </tr>
                </table>
                <p>
                    <div style="color: red">Partition key</div>
                    <div style="color: cyan">Clustering column</div>
                    <div style="color: chartreuse">Data column name</div>
                    <div style="color: orange">Data column value</div>
                </p>

                <aside class="notes">
                <ul>
                <li>let's separate out the different parts of the table
                here</li>
                <li>partition key groups related data together</li>
                <li>clustering column – part of the primary key – provides a
                sort order</li>
                <li>data columns have names and values</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>The Blog in Wide Rows</h1>
                <table>
                    <tr>
                        <th rowspan="2" style="color: red"><code>mycat</code></th>
                        <td nowrap>(<span style="color: cyan">2013-05-08</span>, <span style="color: chartreuse">"title"</span>)</td>
                        <td nowrap>(<span style="color: cyan">2013-05-08</span>, <span style="color: chartreuse">"body"</span>)</td>
                        <td nowrap>(<span style="color: cyan">2013-08-17</span>, <span style="color: chartreuse">"title"</span>)</td>
                        <td nowrap>(<span style="color: cyan">2013-08-17</span>, <span style="color: chartreuse">"body"</span>)</td>
                    </tr>
                    <tr>
                        <td style="color: orange">Jumping in a box</td>
                        <td style="color: orange">Taco loves jumping in boxes.</td>
                        <td style="color: orange; border-bottom: 10px solid gray">Hungry Cat</td>
                        <td style="color: orange; border-bottom: 10px solid gray">Taco is always hungry when I get home from work.</td>
                    </tr>
                    <tr style="border-top: 10px solid gray">
                        <th rowspan="2" style="color: red"><code>code</code></th>
                        <td nowrap>(<span style="color: cyan">2013-07-08</span>, <span style="color: chartreuse">"title"</span>)</td>
                        <td nowrap>(<span style="color: cyan">2013-07-08</span>, <span style="color: chartreuse">"body"</span>)</td>
                    </tr>
                    <tr>
                        <td style="color: orange">Big Data Modeling</td>
                        <td style="color: orange">In a traditional relational database, all your data...</td>
                    </tr>
                </table>
                <p>
                    <div style="color: red">Partition key</div>
                    <div style="color: cyan">Clustering column</div>
                    <div style="color: chartreuse">Data column name</div>
                    <div style="color: orange">Data column value</div>
                </p>

                <aside class="notes">
                <ul>
                <li>here's the same information under the hood</li>
                <li>all the data with a given partition key lives in the same
                wide row</li>
                <li>column headers are a compound data type containing
                clustering key value and data column name</li>
                <li>column values are data column values</li>
                </ul>
                </aside>
                </section>
                </section>

                <section>
                <section>
                <h1>Query-driven schema design</h1>
                <pre><code data-trim class="language-sql">
SELECT * FROM posts
WHERE blog_subdomain = "mycat"
ORDER BY id DESC
LIMIT 10
                </code></pre>

                <aside class="notes">
                <ul>
                <li>design your schema around your access patterns</li>
                <li>most basic access pattern of a blog: most recent posts</li>
                <li>you can even set up the table to order the clustering column
                in reverse, making this query even more efficient</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>Range Queries</h1>
                <pre><code data-trim class="language-sql">
SELECT id, title FROM posts
WHERE blog_subdomain = "mycat"
AND id &gt;= 2013-09-01
AND id &lt;= 2013-09-31
                </code></pre>

                <aside class="notes">
                <ul>
                <li>range queries also another access pattern you can design
                around</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>Secondary indexes</h1>
                <pre><code data-trim class="language-sql">
SELECT id, title FROM posts
WHERE author_id = "9cafe670-16fc-11e3-8ffd-0800200c9a66"
LIMIT 10
                </code></pre>

                <aside class="notes">
                <ul>
                <li>use secondary indices to fill in the gaps</li>
                <li>don't rely on them for your core access patterns</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>Write without reading</h1>
                <pre><code data-trim class="language-sql">
UPDATE posts
SET title = 'Hungry Cat', categories = categories + {'Dinner Time'}
WHERE blog_subdomain = 'mycat' AND id = 2013-07-08
                </code></pre>

                <aside class="notes">
                <ul>
                <li>since cassandra is optimized for writes, you will be most
                efficient if you write without reading</li>
                <li>this can be difficult if you have domain model-level logic
                like validations</li>
                <li>operations on collection columns are atomic and are done
                without reading under the hood</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>Simple primary keys</h1>
                <div style="position:relative">
                <pre><code class="language-sql">
SELECT * FROM blogs
ORDER BY subdomain ASC
                </code></pre>
                <div class="fragment">
                <h2 style="font-size: 3em; position: absolute; top: 0.1em; left: 0; padding-left: 1em; color: red; width: 100%; height: 100%; text-align: left; opacity: 0.7">NOPE</h2>
                </div>
                </div>

                <div style="position: relative">
                <pre class="fragment"><code class="language-sql">
SELECT * FROM blogs
WHERE subdomain &gt; "mycat"
                </code></pre>
                <div class="fragment">
                <h2 style="font-size: 3em; position: absolute; top: 0.1em; left: 0; padding-left: 1em; color: red; width: 100%; height: 100%; text-align: left; opacity: 0.7">NOPE</h2>
                </div>
                </div>

                <aside class="notes">
                <ul>
                <li>simple primary keys should only be used for top-level data</li>
                <li>ideally, you are only ever querying for one of these at a
                time, using the primary key value</li>
                <li>since there is no clustering column, there are no range
                queries or sort ordering</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>Let's make this easy</h1>
                <p>http://github.com/cequel/cequel</p>
                <pre><code class="language-bash">$ gem install cequel --pre</code></pre>

                <aside class="notes">
                <ul>
                <li>cequel is a model layer for CQL</li>
                <li>release candidate of cequel 1.0; supports CQL3, parent-child
                relationships, collections, write-without-reading</li>
                </ul>
                </aside>
                </section>

                <section>
                <h1>That's all, folks</h1>
                <img src="images/taco.jpg">
                </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { window.hljs.initHighlightingOnLoad(); } },
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'lib/js/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'lib/js/data-markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
		</script>

	</body>
</html>

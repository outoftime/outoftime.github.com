<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Big data modeling with Cassandra</title>

		<meta name="description" content="How to use CQL3 to construct robust,
        highly scalable data models">
		<meta name="author" content="Mat Brown">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">
		<link rel="stylesheet" href="css/custom.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
                <h1>Big data modeling with Cassandra</h1>
				</section>

                <section data-background="images/mat.jpg">
                <h1>Mat Brown</h1>
                <h3>@0utoftime</h3>
                <h3>github.com/outoftime</h3>
                <h3>Rap Genius</h3>
                <aside class="notes">
                <p>Used Cassandra/CQL2 at Brewster</p>
                <p>Maintain Cequel ORM</p>
                </aside>
                </section>

                <section>
                <h1>Why Cassandra?</h1>
                </section>

                <section>
                <section>
                <h1>Scalability</h1>
                <img src="images/nettop.jpg">
                <aside class="notes">
                <p>In a traditional relational database, all your data lives on
                one machine. This is usually fine at first.</p>
                </aside>
                </section>

                <section>
                <h1>Scalability</h1>
                <img src="images/server.jpg">
                <aside class="notes">
                <p>As your data set grows, you need bigger and bigger hardware
                to run your single-instance database.</p>
                </aside>
                </section>

                <section>
                <h1>Scalability</h1>
                <img src="images/supercomputer.jpg">
                <aside class="notes">
                <p>Eventually your hardware requirements get entirely out of
                hand.</p>
                </aside>
                </section>
                </section>

                <section>
                <h1>Failure Tolerance</h1>
                <img src="images/tiefighter.jpg">
                <aside class="notes">
                You also never know when a server is going to go down. In a
                single-master data store, losing your master means
                downtime.
                </aside>
                </section>

                <section>
                <h1>Distributed Databases</h1>
                <img src="images/server-ring.jpg">
                <aside class="notes">
                A distributed data store can solve both of these problems. You
                can scale out horizontally, simply by adding more machines to
                the ring. And in a masterless data store, a node going down is
                typically transparent to clients.
                </aside>
                </section>

                <section>
                <h1>Write Optimization</h1>
                <img src="images/firehose.jpg">
                <aside class="notes">
                Cassandra is optimized for large write volumes. Its
                log-structured storage never updates existing files on disk; it
                only creates new files.
                </side>
                </section>

                <section>
                <section>
                <h1>OK, but why Cassandra?</h1>
                <img src="images/fault-tolerance.png">
                </section>

                <section>
                <h1>Tables, Rows, and Columns</h1>
                <table>
                    <tr>
                        <th>id</th>
                        <th>title</th>
                        <th>body</th>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>Big Data Modeling with Cassandra</td>
                        <td>In a traditional relational database, all your data...</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Ulysses</td>
                        <td>Stately, plump Buck Mulligan came from the stairhead...</td>
                    </tr>
                </table>
                <aside class="notes">
                Cassandra structures data in tables, rows, and columns, just
                like an SQL database.
                </aside>
                </section>

                <section>
                <h1>CQL</h1>
                <pre><code data-trim class="language-sql">
SELECT title, body
FROM documents
WHERE id = 1
                </code></pre>
                <aside class="notes">
                Even better, data is accessed and manipulated using CQL, a query
                language inspired by SQL. So you can get all the benefits of a
                write-optimized distributed database while still modeling and
                interacting with your data in a familiar way.
                </aside>
                </section>
                </section>

                <section>
                <section>
                <h1>Why not Cassandra?</h1>
                </section>
                <section>
                <h1>A<span class="fragment">C</span><span class="fragment">I</span><span class="fragment">D</span></h1>
                <p>Atomic</p>
                <p class="fragment" data-fragment-index="0">Consistent</p>
                <p class="fragment" data-fragment-index="1">Isolated</p>
                <p class="fragment" data-fragment-index="2">Durable</p>
                <aside class="notes">
                <p>A series of statements sent as a batch will be applied
                atomically, but there is no concept of multi-statement
                transactions, ROLLBACK, etc.</p>
                <p>Cassandra does not support data integrity constraints such as
                NOT NULL columns, unique indices, foreign keys, etc. Even
                primary keys uniqueness is enforced by simply overwriting data
                at an already existing key. So, there is no concept of
                consistency from the standpoint of ACID.</p>
                <p>Writes in the context of a "transaction" are isolated at the
                row level. We'll get a better sense of what the "row level"
                means later in the presentation.</p>
                <p>Data written to Cassandra is highly durable; write operations
                will not report success until data is persisted durably to disk,
                possibly with multiple copies.</p>
                </aside>
                </section>
                </section>

                <section>
                <section>
                <h1>Data Modeling</h1>
                <p>Let's make a blog!</p>
                </section>

                <section>
                <h1>Blog Table</h1>
                <pre><code data-trim class="language-sql">
CREATE TABLE blogs (
    subdomain varchar PRIMARY KEY,
    name varchar,
    description varchar
)
                </code></pre>
                <aside class="notes">
                Pretty simple â€“ looks exactly like an SQL table. Note that
                the primary key is text: Cassandra doesn't have
                auto-incrementing primary keys, so you will either want to use a
                natural key or a UUID.
                </aside>
                </section>

                <section>
                <h1>Posts Table</h1>
                <pre><code data-trim class="language-sql">
CREATE TABLE posts (
    blog_subdomain varchar,
    id timeuuid,
    title text,
    author_id uuid,
    PRIMARY KEY (blog_subdomain, id)
) 
                </code></pre>
                <pre class="fragment"><code data-trim class="language-sql">
CREATE INDEX ON posts (author_id)
                </code></pre>
                <pre class="fragment"><code data-trim class="language-sql">
ALTER TABLE posts ADD categories set&lt;text&gt;
                </code></pre>
                <aside class="notes">
                <p>Here we have a more interesting example: a compound primary key.
                The primary key is comprised of two columns, which play
                different roles. The first column of the key is called the
                "partition key"; it identifies a collection of related rows, in
                this case the posts in a particular blog. The second column of
                the key is called the "clustering column"; this works much like
                an indexed column in a relational database, allowing you to
                efficiently order by this column and select ranges from it.</p>

                <p>Cassandra supports secondary indexes on non-key columns. It's
                usually recommended that you index columns that have many rows
                per unique value of the column.</p>

                <p>Cassandra also supports collection columns: lists, sets, and
                maps. Using CQL, you can perform atomic mutation operations on
                collection columns.</p>
                </section>
                </section>

                <section>
                <section>
                <h1>Under the hood</h1>
                </section>
                <section>
                <h1>Column families</h1>
                <pre><code class="ruby">
{
  "big-data" =&gt; {1 =&gt; 'Cassandra', 2 =&gt; 'Riak', 4 =&gt; 'HBase'},
  "relational" =&gt; {2 =&gt; 'SQLite', 7 =&gt; 'MySQL'}
}
                </code></pre>
                <aside class="notes">
                Under the hood, Cassandra stores data in simple structures
                called column families. You can think of a column family as a
                hash, where each value is a nested hash whose keys are kept
                in sorted order.
                </aside>
                </section>

                <section>
                <h1>Column Families</h1>
                <table>
                    <tr>
                        <th rowspan="2"><code>big-data</code></th>
                        <th>1</td>
                        <th>2</td>
                        <th>4</td>
                    </tr>
                    <tr>
                        <td>Cassandra</td>
                        <td>Riak</td>
                        <td style="border-bottom: 10px solid gray">HBase</td>
                    </tr>
                    <tr style="border-top: 10px solid gray">
                        <th rowspan="2"><code>relational</th>
                        <th>2</td>
                        <th>7</td>
                    </tr>
                    <tr>
                        <td>SQLite</td>
                        <td>MySQL</td>
                    </tr>
                </table>
                <aside class="notes">
                Another way of looking at the same data. Note that the column
                headers don't have to be consistent between rows. Each row of a
                column family can get up to about 2 billion entries without much
                trouble. We call these "wide rows".
                </aside>
                </section>
                <section>
                <h1>Wide rows stick together</h1>
                <table style="position: relative; top: 1em; left: -10em">
                    <tr>
                        <th rowspan="2"><code>big-data</code></th>
                        <th>1</td>
                        <th>2</td>
                        <th>4</td>
                    </tr>
                    <tr>
                        <td>Cassandra</td>
                        <td>Riak</td>
                        <td>HBase</td>
                    </tr>
                </table>
                <table style="position: relative; top: 5em; left: 5em">
                    <tr>
                        <th rowspan="2"><code>relational</th>
                        <th>2</td>
                        <th>7</td>
                    </tr>
                    <tr>
                        <td>SQLite</td>
                        <td>MySQL</td>
                    </tr>
                </table>
                <aside class="notes">
                Another way of looking at the same data. Note that the column
                headers don't have to be consistent between rows. Each row of a
                column family can get up to about 2 billion entries without much
                trouble. We call these "wide rows".
                </aside>
                </section>

                <section>
                <h1>Compound Types</h1>
                <pre><code>
(2013-05-03, "bikini whale")
(2013-05-03, "manta ray")
(2013-07-08, "catfish")
(2013-07-08, "narwhal")
(2013-09-13, "giant clam")
                </code></pre>
                </section>

                <section>
                <h1>Back to the blog</h1>
                <table>
                    <tr>
                        <th>blog_subdomain</th>
                        <th>id</th>
                        <th>title</th>
                        <th>body</th>
                    </tr>
                    <tr>
                        <td>mycat</td>
                        <td>2013-05-08</td>
                        <td>Jumping in a box</td>
                        <td>Taco loves jumping in boxes.</td>
                    </tr>
                    <tr>
                        <td>mycat</td>
                        <td>2013-08-17</td>
                        <td>Hungry Cat</td>
                        <td>Taco is always hungry when I get home from
                            work.</td>
                    </tr>
                    <tr>
                        <td>code</td>
                        <td>2013-07-08</td>
                        <td>Big Data Modeling</td>
                        <td>In a traditional relational database, all your data...</td>
                    </tr>
                </table>
                </section>

                <section data-transition="none">
                <h1>Back to the blog</h1>
                <table>
                    <tr>
                        <th>blog_subdomain</th>
                        <th>id</th>
                        <th style="color: chartreuse">title</th>
                        <th style="color: chartreuse">body</th>
                    </tr>
                    <tr>
                        <td style="color: red">mycat</td>
                        <td style="color: cyan">2013-05-08</td>
                        <td style="color: orange">Jumping in a box</td>
                        <td style="color: orange">Taco loves jumping in boxes.</td>
                    </tr>
                    <tr>
                        <td style="color: red">mycat</td>
                        <td style="color: cyan">2013-08-17</td>
                        <td style="color: orange">Hungry Cat</td>
                        <td style="color: orange">Taco is always hungry when I get home from
                            work.</td>
                    </tr>
                    <tr>
                        <td style="color: red">code</td>
                        <td style="color: cyan">2013-07-08</td>
                        <td style="color: orange">Big Data Modeling</td>
                        <td style="color: orange">In a traditional relational database, all your data...</td>
                    </tr>
                </table>
                <p>
                    <div style="color: red">Partition key</div>
                    <div style="color: cyan">Clustering column</div>
                    <div style="color: chartreuse">Data column name</div>
                    <div style="color: orange">Data column value</div>
                </p>
                </section>

                <section>
                <h1>The Blog in Wide Rows</h1>
                <table>
                    <tr>
                        <th rowspan="2" style="color: red"><code>mycat</code></th>
                        <td nowrap>(<span style="color: cyan">2013-05-08</span>, <span style="color: chartreuse">"title"</span>)</td>
                        <td nowrap>(<span style="color: cyan">2013-05-08</span>, <span style="color: chartreuse">"body"</span>)</td>
                        <td nowrap>(<span style="color: cyan">2013-08-17</span>, <span style="color: chartreuse">"title"</span>)</td>
                        <td nowrap>(<span style="color: cyan">2013-08-17</span>, <span style="color: chartreuse">"body"</span>)</td>
                    </tr>
                    <tr>
                        <td style="color: orange">Jumping in a box</td>
                        <td style="color: orange">Taco loves jumping in boxes.</td>
                        <td style="color: orange; border-bottom: 10px solid gray">Hungry Cat</td>
                        <td style="color: orange; border-bottom: 10px solid gray">Taco is always hungry when I get home from work.</td>
                    </tr>
                    <tr style="border-top: 10px solid gray">
                        <th rowspan="2" style="color: red"><code>code</code></th>
                        <td nowrap>(<span style="color: cyan">2013-07-08</span>, <span style="color: chartreuse">"title"</span>)</td>
                        <td nowrap>(<span style="color: cyan">2013-07-08</span>, <span style="color: chartreuse">"body"</span>)</td>
                    </tr>
                    <tr>
                        <td style="color: orange">Big Data Modeling</td>
                        <td style="color: orange">In a traditional relational database, all your data...</td>
                    </tr>
                </table>
                <p>
                    <div style="color: red">Partition key</div>
                    <div style="color: cyan">Clustering column</div>
                    <div style="color: chartreuse">Data column name</div>
                    <div style="color: orange">Data column value</div>
                </p>
                </section>
                </section>

                <section>
                <section>
                <h1>Query-driven schema design</h1>
                <pre><code data-trim class="language-sql">
SELECT * FROM posts
WHERE blog_subdomain = "mycat"
ORDER BY id DESC
LIMIT 10
                </code></pre>
                </section>

                <section>
                <h1>Range Queries</h1>
                <pre><code data-trim class="language-sql">
SELECT id, title FROM posts
WHERE blog_subdomain = "mycat"
AND id &gt;= 2013-09-01
AND id &lt;= 2013-09-31
                </code></pre>
                </section>

                <section>
                <h1>Secondary indexes</h1>
                <pre><code data-trim class="language-sql">
SELECT id, title FROM posts
WHERE author_id = "9cafe670-16fc-11e3-8ffd-0800200c9a66"
LIMIT 10
                </code></pre>
                </section>
                </section>

                <section>
                <h1>Let's make this easy</h1>
                <p>http://github.com/cequel/cequel</p>
                <pre><code class="language-bash">$ gem install cequel --pre</code></pre>
                </section>

                <section>
                <h1>That's all, folks</h1>
                <img src="images/taco.jpg">
                </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { window.hljs.initHighlightingOnLoad(); } },
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'lib/js/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'lib/js/data-markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
		</script>

	</body>
</html>
